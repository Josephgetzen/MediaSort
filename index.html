<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Sort</title>
    
    <!-- External Lib for HEIC Support -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>

    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #1e1e1e;
            --primary: #bb86fc;
            --secondary: #03dac6;
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --danger: #cf6679;
            --border: #333;
            --hover: #2c2c2c;
        }

        * { box-sizing: border-box; outline: none; user-select: none; }
        
        body {
            margin: 0; padding: 0;
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            height: 50px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        h1 { font-size: 1.1rem; margin: 0; color: var(--primary); letter-spacing: 1px; font-weight: 600; }

        .btn {
            background: #333;
            color: white;
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn:hover { background: #444; }
        .btn-primary { background: var(--primary); color: #000; font-weight: bold; border: none; }
        .btn-primary:hover { background: #9965f4; }
        .btn-success { background: var(--secondary); color: #000; font-weight: bold; border: none; }
        .btn-success:hover { background: #01bda7; }
        .btn-sm { padding: 2px 6px; font-size: 0.75rem; height: 20px; margin-left: 5px; }

        /* --- Main Layout --- */
        #workspace { flex: 1; display: flex; overflow: hidden; }

        /* --- Left: Preview --- */
        #preview-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: #000;
        }

        #media-container {
            width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
        }

        img, video { max-width: 100%; max-height: 100%; object-fit: contain; }

        #file-info {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-family: monospace;
            pointer-events: none;
            z-index: 10;
        }

        #loading-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center; align-items: center;
            z-index: 20;
        }

        /* --- Right: Sidebar --- */
        #sidebar {
            width: 320px;
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        .sidebar-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        #folder-list {
            flex: 1; overflow-y: auto;
            display: flex; flex-direction: column; gap: 4px;
        }

        .folder-row {
            display: flex; align-items: center;
            background: #2a2a2a;
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            transition: background 0.1s;
        }

        .folder-row:hover { background: #333; }
        .folder-row.active { border-color: var(--primary); background: #332244; }

        /* Visual Indentation logic handled in JS/CSS classes */
        .indent-0 { margin-left: 0px; }
        .indent-1 { margin-left: 20px; border-left: 2px solid #444; }
        .indent-2 { margin-left: 40px; border-left: 2px solid #444; }
        .indent-3 { margin-left: 60px; border-left: 2px solid #444; }
        /* Cap visual indentation at 3, functionally infinite */

        .folder-checkbox {
            width: 16px; height: 16px; margin-right: 8px;
            accent-color: var(--secondary);
            pointer-events: none;
        }

        .folder-name { flex: 1; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        .folder-actions { display: flex; align-items: center; }

        .hotkey-badge {
            background: #444; color: var(--text-dim);
            padding: 1px 5px; border-radius: 3px;
            font-size: 0.7rem; font-family: monospace;
            margin-right: 5px;
            min-width: 18px; text-align: center;
        }

        .add-child-btn {
            background: transparent; border: 1px solid #555;
            color: #aaa; border-radius: 50%;
            width: 20px; height: 20px;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; line-height: 1;
            padding: 0;
        }
        .add-child-btn:hover { background: #555; color: white; }

        /* --- Footer --- */
        footer {
            height: 60px;
            background-color: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px;
        }

        #status-bar { font-size: 0.85rem; color: var(--text-dim); }

        /* --- Modals --- */
        .modal {
            display: none; position: fixed; z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: var(--bg-panel);
            padding: 25px;
            border: 1px solid var(--border);
            border-radius: 8px;
            width: 500px; max-width: 90%;
            max-height: 85vh; overflow-y: auto;
        }
        .modal h2 { margin-top: 0; color: var(--primary); border-bottom: 1px solid #333; padding-bottom: 10px; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-size: 0.9rem; color: var(--text-main); }
        .checkbox-label { display: flex; align-items: center; gap: 10px; cursor: pointer; }
        
        /* Settings Table */
        .settings-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .settings-table th { text-align: left; padding: 5px; border-bottom: 1px solid #444; color: var(--text-dim); font-size: 0.8rem; }
        .settings-table td { padding: 5px; border-bottom: 1px solid #333; }
        .settings-input { 
            background: #121212; border: 1px solid #444; color: white; width: 50px; text-align: center; 
            padding: 4px; border-radius: 4px; text-transform: uppercase;
        }
        .settings-input:focus { border-color: var(--primary); }

        /* Spinner */
        .spinner {
            border: 4px solid rgba(255,255,255,0.1);
            width: 36px; height: 36px; border-radius: 50%;
            border-left-color: var(--secondary);
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <header>
        <h1>Media Sort</h1>
        <button class="btn" onclick="openSettings()">Settings</button>
    </header>

    <div id="workspace">
        <div id="preview-area">
            <div id="file-info">No files loaded</div>
            <div id="media-container"></div>
            <div id="loading-overlay"><div class="spinner"></div></div>
        </div>

        <div id="sidebar">
            <div class="sidebar-header">
                <span>Output Folders</span>
                <button class="btn btn-sm" onclick="addFolder(null)" title="Create Root Folder">+</button>
            </div>
            <div id="folder-list">
                <!-- Folders injected here -->
            </div>
        </div>
    </div>

    <footer>
        <button class="btn" onclick="importDirectory()">Import Source</button>
        <div id="status-bar">Ready</div>
        <button class="btn btn-success" onclick="exportFiles()">Save / Copy</button>
    </footer>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <h2>Settings</h2>
            
            <div class="form-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="chk-copy-unsorted">
                    Copy unsorted media to "Unsorted" folder
                </label>
            </div>

            <div class="form-group">
                <label>Folder Hotkey Configuration</label>
                <p style="font-size: 0.8rem; color: #888; margin-top:0;">
                    Hotkeys 1-6 are assigned automatically to the top folders. You can override specific folders here.
                </p>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table class="settings-table">
                        <thead>
                            <tr>
                                <th>Folder Path</th>
                                <th style="width: 70px;">Hotkey</th>
                            </tr>
                        </thead>
                        <tbody id="settings-hotkey-list">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div style="text-align: right; margin-top: 20px;">
                <button class="btn btn-primary" onclick="closeSettings()">Save & Close</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * STATE MANAGEMENT
         */
        const state = {
            files: [],           // Array of FileHandle
            // Folder structure: { id, name, parentId, manualHotkey }
            folders: [],         
            associations: {},    // Map<fileName, Set<folderId>>
            currentIndex: -1,
            settings: {
                copyUnsorted: false
            },
            directoryHandle: null,
            objectURLCache: new Map(), // Map<index, stringUrl>
        };

        const supportedImages = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'bmp', 'svg'];
        const supportedVideos = ['mp4', 'webm', 'mov', 'm4v'];
        const appleFormats = ['heic'];
        
        // DOM Elements
        const mediaContainer = document.getElementById('media-container');
        const fileInfo = document.getElementById('file-info');
        const folderListEl = document.getElementById('folder-list');
        const statusBar = document.getElementById('status-bar');
        const loader = document.getElementById('loading-overlay');

        /**
         * INITIALIZATION & IMPORT
         */
        async function importDirectory() {
            try {
                if (!window.showDirectoryPicker) {
                    alert("Browser not supported. Please use Chrome or Edge.");
                    return;
                }

                state.directoryHandle = await window.showDirectoryPicker();
                state.files = [];
                state.associations = {};
                state.currentIndex = -1;
                
                statusBar.textContent = "Scanning...";
                
                for await (const entry of getFilesRecursively(state.directoryHandle)) {
                    const ext = entry.name.split('.').pop().toLowerCase();
                    if ([...supportedImages, ...supportedVideos, ...appleFormats].includes(ext)) {
                        state.files.push(entry);
                        state.associations[entry.name] = new Set();
                    }
                }

                // Sort files alphanumerically
                state.files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

                if (state.files.length > 0) {
                    state.currentIndex = 0;
                    renderSidebar();
                    await loadMedia(0);
                    statusBar.textContent = `Loaded ${state.files.length} files.`;
                } else {
                    statusBar.textContent = "No supported media found.";
                }

            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error(err);
                    alert("Import error: " + err.message);
                }
            }
        }

        async function* getFilesRecursively(entry) {
            if (entry.kind === 'file') yield entry;
            else if (entry.kind === 'directory') {
                for await (const handle of entry.values()) yield* getFilesRecursively(handle);
            }
        }

        /**
         * PREVIEW LOGIC
         */
        async function loadMedia(index) {
            if (index < 0 || index >= state.files.length) return;

            const handle = state.files[index];
            fileInfo.textContent = `[${index + 1}/${state.files.length}] ${handle.name}`;
            updateSidebarActiveState(); // Highlight folders for this file

            let url = state.objectURLCache.get(index);
            
            if (!url) {
                loader.style.display = 'flex';
                try {
                    const file = await handle.getFile();
                    url = await processFileForPreview(file);
                    state.objectURLCache.set(index, url);
                    cleanCache(index);
                } catch (e) {
                    loader.style.display = 'none';
                    mediaContainer.innerHTML = `<div style="color:red">Preview Unavailable</div>`;
                    return;
                }
            }
            renderPreview(url, handle.name);
            
            // Preload next
            if (index + 1 < state.files.length && !state.objectURLCache.has(index + 1)) {
                preload(index + 1);
            }
        }

        async function processFileForPreview(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (ext === 'heic') {
                try {
                    const blob = await heic2any({ blob: file, toType: "image/jpeg", quality: 0.5 });
                    return URL.createObjectURL(blob);
                } catch(e) { throw e; }
            }
            return URL.createObjectURL(file);
        }

        function renderPreview(url, filename) {
            const ext = filename.split('.').pop().toLowerCase();
            mediaContainer.innerHTML = '';
            
            let el;
            if (supportedVideos.includes(ext) || ext === 'mov') {
                el = document.createElement('video');
                el.src = url;
                el.controls = true;
                el.autoplay = true;
                el.loop = true;
                el.muted = true; // Often required for autoplay
            } else {
                el = document.createElement('img');
                el.src = url;
            }
            
            el.onload = el.oncanplay = () => loader.style.display = 'none';
            mediaContainer.appendChild(el);
            setTimeout(() => loader.style.display = 'none', 300);
        }

        async function preload(index) {
            const handle = state.files[index];
            const file = await handle.getFile();
            state.objectURLCache.set(index, await processFileForPreview(file));
        }

        function cleanCache(currIdx) {
            for (const [k, url] of state.objectURLCache.entries()) {
                if (Math.abs(k - currIdx) > 5) {
                    URL.revokeObjectURL(url);
                    state.objectURLCache.delete(k);
                }
            }
        }

        /**
         * FOLDER MANAGEMENT & RECURSIVE SIDEBAR
         */
        function addFolder(parentId = null) {
            const name = prompt(parentId ? "Sub-folder Name:" : "Folder Name:");
            if (name) {
                const id = Date.now().toString() + Math.random().toString(16).slice(2);
                state.folders.push({ id, name, parentId, manualHotkey: null });
                renderSidebar();
            }
        }

        // Returns flat list of folders in DFS order (Visual Order)
        function getVisualFolderList() {
            const result = [];
            const buildTree = (pid, depth) => {
                const children = state.folders
                    .filter(f => f.parentId === pid)
                    .sort((a,b) => a.name.localeCompare(b.name)); // Alphabetical sibling sort
                
                children.forEach(child => {
                    result.push({ ...child, depth });
                    buildTree(child.id, depth + 1);
                });
            };
            buildTree(null, 0);
            return result;
        }

        function renderSidebar() {
            folderListEl.innerHTML = '';
            const visualList = getVisualFolderList();

            visualList.forEach((folder, index) => {
                const row = document.createElement('div');
                row.className = 'folder-row';
                // Indentation class capped at 3
                const indentClass = `indent-${Math.min(folder.depth, 3)}`;
                row.classList.add(indentClass);
                row.dataset.id = folder.id;

                // Click event (avoid triggering when clicking buttons)
                row.onclick = (e) => {
                    if(e.target.tagName === 'BUTTON') return;
                    toggleFolderAssignment(folder.id);
                };

                // Checkbox
                const chk = document.createElement('input');
                chk.type = 'checkbox';
                chk.className = 'folder-checkbox';
                chk.checked = isFolderSelected(folder.id);
                row.appendChild(chk);

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.className = 'folder-name';
                nameSpan.innerText = folder.name;
                row.appendChild(nameSpan);

                // Actions (Hotkey + Add Child)
                const actions = document.createElement('div');
                actions.className = 'folder-actions';

                // Determine Hotkey Display
                // If manual exists, show it. Else if index < 6, show index+1.
                let displayKey = folder.manualHotkey ? folder.manualHotkey : (index < 6 ? (index + 1) : null);
                
                if (displayKey) {
                    const badge = document.createElement('span');
                    badge.className = 'hotkey-badge';
                    badge.innerText = displayKey;
                    actions.appendChild(badge);
                }

                // Add Child Button
                const addBtn = document.createElement('button');
                addBtn.className = 'add-child-btn';
                addBtn.innerText = '+';
                addBtn.title = 'Create Sub-folder';
                addBtn.onclick = () => addFolder(folder.id);
                actions.appendChild(addBtn);

                row.appendChild(actions);
                folderListEl.appendChild(row);
            });
        }

        function toggleFolderAssignment(folderId) {
            if (state.currentIndex === -1) return;
            const fName = state.files[state.currentIndex].name;
            if (!state.associations[fName]) state.associations[fName] = new Set();
            
            const set = state.associations[fName];
            if (set.has(folderId)) set.delete(folderId);
            else set.add(folderId);

            // Update UI
            updateSidebarActiveState();
        }

        function isFolderSelected(fid) {
            if (state.currentIndex === -1) return false;
            const set = state.associations[state.files[state.currentIndex].name];
            return set ? set.has(fid) : false;
        }

        function updateSidebarActiveState() {
            if (state.currentIndex === -1) return;
            const set = state.associations[state.files[state.currentIndex].name] || new Set();
            
            const rows = folderListEl.querySelectorAll('.folder-row');
            rows.forEach(r => {
                const id = r.dataset.id;
                const chk = r.querySelector('.folder-checkbox');
                const isChecked = set.has(id);
                chk.checked = isChecked;
                if(isChecked) r.classList.add('active');
                else r.classList.remove('active');
            });
        }

        /**
         * INPUT HANDLING (Nav & Hotkeys)
         */
        window.addEventListener('keydown', (e) => {
            if (document.querySelector('.modal').style.display === 'flex') return;
            if (state.currentIndex === -1) return;

            const key = e.key.toUpperCase();

            // Navigation
            if (e.key === 'ArrowRight' || key === 'D') {
                if (state.currentIndex < state.files.length - 1) loadMedia(++state.currentIndex);
            } 
            else if (e.key === 'ArrowLeft' || key === 'A') {
                if (state.currentIndex > 0) loadMedia(--state.currentIndex);
            }
            // Folder Hotkeys
            else {
                handleFolderHotkey(key);
            }
        });

        function handleFolderHotkey(key) {
            const visualList = getVisualFolderList();
            
            // 1. Check for manual override match
            const manualMatch = state.folders.find(f => f.manualHotkey === key);
            if (manualMatch) {
                toggleFolderAssignment(manualMatch.id);
                return;
            }

            // 2. Check for automatic 1-6
            // Only applicable if key is 1-6
            if (['1','2','3','4','5','6'].includes(key)) {
                const idx = parseInt(key) - 1;
                if (visualList[idx]) {
                    toggleFolderAssignment(visualList[idx].id);
                }
            }
        }

        /**
         * SETTINGS MODAL
         */
        function openSettings() {
            document.getElementById('settings-modal').style.display = 'flex';
            document.getElementById('chk-copy-unsorted').checked = state.settings.copyUnsorted;
            renderSettingsTable();
        }

        function closeSettings() {
            state.settings.copyUnsorted = document.getElementById('chk-copy-unsorted').checked;
            
            // Save hotkeys from table inputs
            const rows = document.querySelectorAll('.settings-hotkey-row');
            rows.forEach(row => {
                const fid = row.dataset.id;
                const val = row.querySelector('input').value.trim().toUpperCase().charAt(0);
                const folder = state.folders.find(f => f.id === fid);
                if (folder) folder.manualHotkey = val || null;
            });

            document.getElementById('settings-modal').style.display = 'none';
            renderSidebar(); // Re-render to show updated keys
        }

        function renderSettingsTable() {
            const tbody = document.getElementById('settings-hotkey-list');
            tbody.innerHTML = '';
            const visualList = getVisualFolderList();

            visualList.forEach(f => {
                const tr = document.createElement('tr');
                tr.className = 'settings-hotkey-row';
                tr.dataset.id = f.id;
                
                // Build path string for clarity
                let pathStr = f.name;
                let parent = state.folders.find(p => p.id === f.parentId);
                while(parent) {
                    pathStr = parent.name + ' / ' + pathStr;
                    parent = state.folders.find(p => p.id === parent.parentId);
                }

                const tdName = document.createElement('td');
                tdName.textContent = pathStr;
                
                const tdInput = document.createElement('td');
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'settings-input';
                input.maxLength = 1;
                input.value = f.manualHotkey || '';
                
                tdInput.appendChild(input);
                tr.appendChild(tdName);
                tr.appendChild(tdInput);
                tbody.appendChild(tr);
            });
        }

        /**
         * EXPORT LOGIC
         */
        async function exportFiles() {
            if (state.files.length === 0) return;
            if (!confirm(`Ready to copy files to destination?`)) return;

            try {
                const destRoot = await window.showDirectoryPicker({ mode: 'readwrite' });
                
                statusBar.textContent = "Exporting...";
                let count = 0;

                // 1. Resolve Folder Paths
                // We need to map folderID -> DirectoryHandle in destination
                const folderHandles = {}; 

                // Recursively create handles
                const getHandleForFolder = async (folderId) => {
                    if (folderHandles[folderId]) return folderHandles[folderId];
                    
                    const folder = state.folders.find(f => f.id === folderId);
                    if (!folder) return null;

                    let parentHandle = destRoot;
                    if (folder.parentId) {
                        parentHandle = await getHandleForFolder(folder.parentId);
                    }
                    
                    const handle = await parentHandle.getDirectoryHandle(folder.name, { create: true });
                    folderHandles[folderId] = handle;
                    return handle;
                };

                // Create Unsorted handle if needed
                let unsortedHandle = null;
                if (state.settings.copyUnsorted) {
                    unsortedHandle = await destRoot.getDirectoryHandle("Unsorted", { create: true });
                }

                // 2. Copy Loop
                for (let i = 0; i < state.files.length; i++) {
                    const src = state.files[i];
                    statusBar.textContent = `Copying ${i+1}/${state.files.length}: ${src.name}`;
                    
                    const assignedIds = state.associations[src.name];
                    
                    if (assignedIds && assignedIds.size > 0) {
                        for (const fid of assignedIds) {
                            const destDir = await getHandleForFolder(fid);
                            await copyFile(src, destDir);
                            count++;
                        }
                    } else if (state.settings.copyUnsorted && unsortedHandle) {
                        await copyFile(src, unsortedHandle);
                        count++;
                    }
                }

                statusBar.textContent = `Export complete. Copies created: ${count}`;
                alert(`Export Complete! ${count} files copied.`);

            } catch (err) {
                console.error(err);
                statusBar.textContent = "Export Failed.";
                alert("Export failed: " + err.message);
            }
        }

        async function copyFile(fileHandle, dirHandle) {
            const file = await fileHandle.getFile();
            const newHandle = await dirHandle.getFileHandle(file.name, { create: true });
            const writable = await newHandle.createWritable();
            await writable.write(file);
            await writable.close();
        }

    </script>
</body>
</html>
